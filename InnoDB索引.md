# 索引的概念
索引，在 MySQL 中也叫做"键(key)"，是存储引擎用于快速找到记录的一种数据结构。

# 索引的基础
要理解 MySQL 中索引是如何工作的，最简单的方法就是去看看一本书的"目录"部分，如果想在一本书中找到某个特定的主题，一般会先看书的"目录"，然后找到对应的页码。

在 MySQ L中，存储引擎用类似的方法使用索引，其先在索引中找到对应值，然后根据匹配的索引记录找到对应的数据行。假如要运行下面的查询：

```sql
SELECT first_name FROM actor WHERE actor_id = 5;
```

如果在 actor_id 列上建有索引，则 MySQL 将使用该索引找到 actor_id 为 5 的行，也就是说，MySQL 先在索引上按值进行查找，然后返回所有包含该值的数据行。

索引可以包含一个或多个列的值。如果索引包含多个列，那么列的顺序也十分重要，因为 MySQL 只能高效地使用索引的最左前缀列。创建一个包含两个列的索引，和创建两个只包含一列的索引是大不相同的。

# 索引的类型
- 常规索引

常规索引，也叫普通索引（index或key），它可以常规地提高查询效率。一张数据表中可以有多个常规索引。

```sql
ALTER TABLE 'table_name' ADD INDEX index_name('col');
```

- 主键索引

主键索引（Primary Key），也简称主键。它可以提高查询效率，并提供唯一性约束。一张表中有且只能有一个主键。

```sql
ALTER TABLE 'table_name' ADD PRIMARY KEY pk_index('col');
```

- 唯一索引

唯一索引（Unique Key），可以提高查询效率，并提供唯一性约束。一张表中可以有多个唯一索引。

```sql
ALTER TABLE 'table_name' ADD UNIQUE index_name('col');
```

**主键索引与唯一索引的区别：主键索引在定义时使用的关键字是PRIMARY，而唯一索引使用的关键字是UNIQUE；主键索引一定是唯一索引，反之不成立；主键索引有且只有一个，唯一索引可以有多个。**

- 全文索引

全文索引（Full Text），对文本的内容进行分词，可以提高全文搜索的查询效率，一般使用Sphinx。但Sphinx不支持中文检索，Coreseek是支持中文的全文检索引擎，也称作具有中文分词功能的Sphinx。

Sphinx是一个基于SQL的全文检索引擎，可以结合MySQL、PostgreSQL做全文搜索，它可以提供比数据库本身更专业的搜索功能，使得应用程序更容易实现专业化的全文检索。

全文索引可以使 **LIKE %word%** 走索引查询。


```sql
ALTER TABLE 'table_name' ADD FULLTEXT INDEX ft_index('col');
```

- 前缀索引

如果索引列很长，就会使得索引变得大且慢，这个时候，可以索引该字符列开始的部分字符，这样可以大幅节约索引空间，提高索引效率。但是需要注意的是，这样也可能会降低索引的选择性。

```sql
ALTER TABLE 'table_name' ADD INDEX index_name(col1(4),col2(3));
```

```
表示使用col1的前4个字符和col2的前3个字符作为索引
```

- 组合索引

把多个列值组合成一个索引。

```sql
ALTER TABLE 'table_name' ADD INDEX index_name('col1','col2','col3');
```

组合索引必须遵循"最左前缀原则"，把最常检索的列放在最左。

索引生效的情形有：(col1)，(col1,col2)，(col1,col2,col3)

只能使用索引的第一列：(col1,col3)

索引失效的情形有：(col2)，(col3)，(col2,col3)

- 合并索引

使用多个单列索引作为查询条件，进行查询。

```sql
ALTER TABLE 'table_name' ADD INDEX index_name('col1');

ALTER TABLE 'table_name' ADD INDEX index_name('col2');

ALTER TABLE 'table_name' ADD INDEX index_name('col3');

SELECT * FROM table_name WHERE col1='col1' AND col2='col2' AND col3='col3';
```

组合索引与合并索引的区别

![](images/index.png)

从上图中可以看出，组合索引综合保存了COL1和COL2的数据，它不需要在2个索引表之间进行关联查询，所以速度会更快。

**尽量使用组合索引，而不是合并索引**

# 索引的方法

1. B-Tree索引

假如有如下数据表：

```sql
CREATE TABLE People (
  last_name VARCHAR(50) NOT NULL,
  first_name VARCHAR(50) NOT NULL,
  dob DATE NOT NULL,
  gender ENUM('m','f') NOT NULL,
  key(last_name, first_name, dob)
);
```

B-Tree索引适用于全键值、键值范围或键前缀查找。其中键前缀查找只适用于根据最左前缀的查找。前面所述的索引对如下类型的查询有效。

- 全值匹配

全值匹配指的是和索引中的所有列进行匹配，上述索引可用于查找姓名为 Cuba Allen、出生于 1960-01-01 的人。

```sql
SELECT * FROM People WHERE last_name = 'Allen' AND first_name = 'Cuba' AND dob = '1960-01-01';
```

- 匹配最左前缀

上述索引可用于查找所有姓为 Allen 的人，即只使用索引的第一列。

```sql
SELECT * FROM People WHERE last_name = 'Allen';
```

- 匹配列前缀

也可以只匹配某一列的值的开关部分。上述索引可用于查找所有以 J 开头的姓的人。这里也只使用了索引的第一列。

```sql
SELECT * FROM People WHERE last_name LIKE 'J%';
```

- 匹配范围值

上述索引可用于查找姓在 Allen 和 Barrymore 之间的人。这里也只使用了索引的第一列。

```sql
SELECT * FROM People WHERE last_name BETWEEN 'Allen' AND 'Barrymore';
```

- 精确匹配某一列并范围匹配另外一列

上述索引可用于查找所有姓为 Allen，并且名字是字母 K 开头的人。即第一列 last_name 全匹配，第二列 first_name 范围匹配。

```sql
SELECT * FROM People WHERE last_name = 'Allen' AND first_name = 'K%';
```

- 只访问索引的查询

查询只需要访问索引，而无须访问数据行，即覆盖索引。

```sql
SELECT last_name, first_name, dob FROM People WHERE last_name = 'Allen' AND first_name = 'Cuba' AND dob = '1960-01-01';
```

**B-Tree索引的限制:**

- 如果不是按照索引的最左列开始查找，则无法使用索引。上述索引无法用于查找名字为 Bill 的人，也无法查找某个特定生日的人，因为这两列都不是最左数据列。类似地，也无法查找姓氏以某个字母结尾的人。

例如，以下查询无法使用索引:

```sql
SELECT * FROM People WHERE first_name = 'Bill';

SELECT * FROM People WHERE dob = '1960-01-01';

SELECT * FROM People WHERE first_name = 'Bill' AND dob = '1960-01-01';

SELECT * FROM People WHERE last_name LIKE '%J';
```

- 不能跳过索引中的列。也就是说，上述索引无法用于查找姓为 Smith 并且在某个特定日期出生的人。如果不指定名 (first_name)，则查询只能使用索引的第一列。

例如，以下查询就只能使用索引的第一列:

```sql
SELECT * FROM People WHERE last_name = 'Smith' AND dob = '1960-01-01';
```

- 如果查询中有某个列的范围查询，则其右边所有的列都无法使用索引优化查找。

例如，以下查询就只能使用索引的前两列，因为 LIKE 是一个范围条件:

```sql
SELECT * FROM People WHERE last_name = 'Smith" AND first_name LIKE 'J%' AND dob = '1976-12-23';
```

如果范围查询列值的数量有限，那么可以通过使用多个等于条件来代替范围条件。

**总结：索引列的顺序非常重要，上述的查询限制都和索引列的顺序有关。在优化性能的时候，可能需要使用相同的列但顺序不同的索引来满足不同类型的查询需求。**

2. HASH索引

哈希索引基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码(hash code)，哈希码是一个较小的值，并且不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。

B-Tree索引的限制:

- 哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。不过，访问内存中的行的速度很快，所以大部分情况下这一点对性能的影响并不明显。

- 哈希索引数据并不是按照索引值顺序存储的，所以也就无法用于排序。

- 哈希索引也不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的。例如，在数据列 (A, B) 上建立哈希索引，如果查询只有数据列   A，则无法使用该索引。

- 哈希索引只支持等值比较查询，包括 = 、 IN() 、 <=>。也不支持任何范围查询，例如 WHERE price > 100。

- 访问哈希索引的数据非常快，除非有很多哈希冲突（不同的索引列值却有相同的哈希值）。当出现哈希冲突的时候，存储引擎必须遍历链表中所有的行指针，逐行进行比较，直到找到所有符合条件的行。

- 如果哈希冲突很多的话，一些索引维护操作的代价也会很高。例如，如果在某个选择性很低（哈希冲突很多）的列上建立哈希索引，那么当从表中删除一行时，存储引擎需要遍历对应哈希值的链表中的每一行，找到并删除对应行的引用，冲突越多，代价越大。

# 索引的优点
索引可以快速地定位到表的指定位置。但是这并不是索引的唯一作用，根据创建索引的数据结构不同，索引也有一些其他的附加作用。

最常见的 B-Tree 索引，按照顺序存储数据，所以 MySQL 可以用来做 ORDER BY 和 GROUP BY 操作。因为数据是有序的，所有 B-Tree 也就会将相关的残值都存储在一起。最后，因为索引中存储了实际的列表，所以某些查询只使用索引就能够完成全部查询。据此特性，总结下来索引有如下三个优点：

1. 索引大大减少了服务器需要扫描的数据量。

2. 索引可以避免排序和临时表。

3. 索引可以将随机 I/O 变为顺序 I/O。

**索引并不总是最好的工具。总的来说，只有当索引帮助存储引擎快速查找到记录带来的好处大于其带来的额外工作时，索引才是有效的。对于非常小的表，大部分情况下简单的全表扫描更高效。对于中到大型的表，索引就非常有效。但对于特大型的表，建立和使用索引的代价将随之增长。这种情况下，则需要一种技术可以直接区分出查询需要的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。**

**如果表的数量特别多，可以建立一个元数据信息表，用来查询需要用到的某些特性。例如执行那些需要聚合多个应用分布在多个表的数据的查询，则需要记录"哪个用户的信息存储在哪个表中"的元数据，这样在查询时就可以直接忽略那些不包含指定用户信息的表。对于大型系统，这是一个常用的技巧。对于 TB 级别的数据，定位单条记录的意义不大，所以经常会使用块级别元数据技术来替代索引。**

# 高性能的索引策略
正确地创建和使用索引是实现高性能查询的基础。

## 独立的列
我们通常会看到一些查询不当地使用索引，或者使得 MySQL 无法使用已有的索引。如果查询中的列不是独立的，则 MySQL 就不会使用索引。"独立的列"是指索引列不能是表达式的一部分，也不能是函数的参数。

例如，下面这个查询无法使用 actor_id 列的索引：

```sql
SELECT actor_id FROM actor WHERE actor_id + 1 = 5;
```

下面是另一个常见的错误：

```sql
SELECT actor_id FROM actor WHERE TO_DAYS(CURRENT_DATE) - TO_DAYS(date_col) <= 10;
```

## 多列索引
很多人对多列索引的理解都不够。一个常见的错误就是，为每个列创建独立的索引，或者按照错误的顺序创建多列索引。

下面是为每个列创建独立索引的例子：

```sql
CREATE TABLE t(
  c1 INT,
  c2 INT,
  c3 INT,
  KEY(c1),
  KEY(c2),
  KEY(c3)
);
```

这种索引策略，一般是由于人们听到一些专家诸如"把 WHERE 条件里面的列都建上索引"这样模糊的建议导致的。实际上这个建议是非常错误的。这样一来最好的情况下也只能是一星索引，其性能比起真正最优的索引可能差几个数量级。有时如果无法设计一下三星索引，那么不如忽略掉 WHERE 子句，集中精力优化索引列的顺序，或者创建一个全覆盖索引。

**在多个列上创建独立的单列索引大部分情况下并不能提高 MySQL 的查询性能**。针对这种情况，虽然有索引合并的策略在一定程序上可以定位到指定的行，但这并不是最好的选择。

```
三星系统：

索引将相关的记录放到一起则获得一星；

如果索引中的数据顺序和查找中的排列顺序一致则获得二星；

如果索引中的列包含了查询中需要的全部列则获得三星。
```

## 选择合适的索引列顺序
我们遇到的最容易引起困惑的问题就是索引列的顺序。正确的顺序依赖于使用该索引的查询，并且同时需要考虑如何更好地满足排序和分组的需要。

**在一个多列 B-Tree 索引中，索引列的顺序意味着索引首先按照最左列进行排序，其次是第二列，等等。所以，索引可以按照升序或者降序进行扫描，以满足精确符合列顺序的 ORDER BY 、GROUP BY 和 DISTINCT 等子句的查询需求。所以多列索引的列顺序至关重要。**

对于如何选择索引的列顺序有一个经验法则：将选择性最高的列放到索引最前列。这个建议有用吗？在某些场景可能有帮助，但通常不如避免随机 I/O 和排序那么重要，考虑问题需要更全面。**场景不同则选择不同，没有一个放之四海而皆准的法则。**

当不需要考虑排序和分组时，将选择性最高的列放在前面通常是很好的。这时候索引的作用只是用于优化 WHERE 条件的查找。在这种情况下，这样设计的索引确实能够最快地过滤出需要的行，对于在 WHERE 子句中只使用了索引部分前缀列的查询来说选择性也更高。然而，性能不只是依赖于所有索引的选择性（整体基数），也和查询条件 的具体值有关，也就是和值的分布有关。可能需要根据那些运行频率最高的查询来调整索引列的顺序，让这种情况下索引的选择性最高。

以下面的查询为例：

```sql
SELECT * FROM payment WHERE staff_id = 2 AND customer_id = 5;
```

是应该创建一个 (staff_id, customer_id) 索引还是应该颠倒一下顺序？可以跑一些查询来确定在这个表中值的分布情况，并确定哪个列的选择性更高。先用下面的查询预测一下，看看各个 WHERE 条件的分支对应的数据基数有多大：

```sql
SELECT SUM(staff_id = 2), SUM(customer_id = 5) FROM payment \G;
******************* 1.row *******************
   SUM(staff_id = 2): 7992
SUM(customer_id = 5): 30
```

根据前面的经验法则，应该将索引列 customer_id 放到前面，因为对应条件值的 customer_id 数量更小。我们再来看看对于这个 customer_id 的条件值，对应的 staff_id 列的选择性如何：

```sql
SELECT SUM(staff_id = 2) FROM payment WHERE customer_id = 5 \G;
******************* 1.row *******************
SUM(staff_id = 2): 17
```

这样做有一个地方需要注意，查询的结果非常依赖于选定的具体的值。如果按上述办法优化，可能对其他一引起条件值的查询不公平，存储引擎的整体性能可能变得更糟，或者其他某些查询的运行变得不如预期。

如果是从诸如 pt-query-digest 这样的工具的报告中提取"最差"查询，那么再按上述办法选定的索引顺序往往是非常高效的。如果没有类似的具体查询来运行，那么最好还是按经验法则来做，因为经验法则考虑的是全局基数和选择性，而不是某个具体查询：

```sql
SELECT COUNT( DISTINCT staff_id) / COUNT(*) AS staff_id_selectivity, COUNT( DISTINCT customer_id) / COUNT(*) AS customer_id_selectivity, COUNT(*) FROM payment \G;
******************* 1.row *******************
   staff_id_selectivity: 0.0001
customer_id_selectivity: 0.0373
               COUNT(*): 16049
```

customer_id的选择性更高，所以将其作为索引列的第一列：

```sql
ALTER TABLE payment ADD KEY(customer_id, staff_id);
```

## 聚簇索引（Cluster Index)

聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。InnoDB的聚簇索引实际上在同一结构中保存了 B-Tree 索引和数据行。

当表中有聚簇索引时，它的数据行实际上存放在索引的叶子页（leaf page）中，也就是说，叶子页包含了行的全部数据，而节点页只包含了索引列的数据。

InnoDB 通过主键聚集数据，如果没有定义主键，InnoDB 会选择一个唯一的非空索引代替。如果没有这样的索引，InnoDB 会隐式定义一个主键来作为聚簇索引。

聚簇索引的优点

- 可以把相关的数据保存在一起

- 数据访问更快。聚簇索引将索引和数据保存在同一个 B-Tree 中，因此，从聚簇索引中获取数据通常比非聚簇索引要快

- 使用覆盖索引扫描的查询可以直接使用节点页中的主键值

聚簇索引的缺点

- 聚簇索引最大限度地提高了 I/O 密集型应用的性能，但如果数据全部放在内存中，则访问的顺序就没那么重要了，聚簇索引也就没什么优势了

- 插入速度严重依赖于插入顺序。按照主键的顺序插入是插入数据到 InnoDB 表中速度最快的方式；但如果不是按照主键顺序插入数据，那么，在操作完毕后，最好使用 OPTIMIZE TABLE 命令重新组织一下表

- 更新聚簇索引列的代价很高，因为会强制 InnoD B将每个被更新的行移动到新的位置

- 基于聚簇索引的表在插入新行，或者主键被更新，导致需要移动行的时候，可能面临“页分裂（page split）”的问题。页分裂会导致表占用更多的磁盘空间

在 InnoDB 中，聚簇索引就是"表"，所以不像MyISAM那样需要独立的行存储。聚簇索引的每一个叶子节点都包含了主键值、事务ID、用于事务和 MVCC（多版本控制）的回滚指针以及所有的剩余列

InnoDB 的二级索引（非聚簇索引）和聚簇索引差别很大，二级索引的叶子节点中存储的不是"行指针"，而是主键值。故通过二级索引查找数据时，会进行两次索引查找。存储引擎需要先查找二级索引的叶子节点来获得对应的主键值，然后根据这个主键值到聚簇索引中查找对应的数据行

**非聚簇索引(Secondary Index)**

InnoDB 中所有除聚簇索引以外的所有索引都被称为辅助索引，即非聚簇索引。对于辅助索引，叶子节点并不包含行记录的全部数据。叶子节点除了包含键值以外，每个叶子节点的索引行中还包含一个主键值。通过主键值 InnoDB 存储引擎可以再次在聚集索引中找到对应索引项的行数据。辅助索引的存在不会影响数据在聚集索引中的组织，因此每张表上可以存在多个辅助索引。当通过辅助索引来查找数据时，InnoDB 存储引擎会遍历辅助索引并获得页中的指向主键索引的主键，然后再通过主键索引依次找到一个完整的行记录。因此，这就意味着通过辅助索引查找行，存储引擎先找到辅助索引的叶子节点，得到对应的主键值，然后根据该主键值去聚集索引上查找对应的行数据。也即一次辅助索引查找需要两次对 B+Tree 进行查找。

## 覆盖索引
通常我们都会根据查询的 WHERE 条件来创建合适的索引,不过这只是索引优化的一个方面。设计优秀的索引应该考虑到整个查询，而不单单是 WHERE 条件部分。索引确实是一种查找数据的高效方式，但是 MySQL 也可以使用索引来直接获取列的数据，这样就不再需要读取数据行。如果索引的叶子节点中已经包含了要查询的数据，那么还有什么必要再回表查询呢？如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为覆盖索引。

覆盖索引是非常有用的工具，能够极大地提高性能。考虑一下如果查询只需要扫描索引而无须回表，会带来多少好外：

- 索引条目通常远小于数据行大小，所以如果只需要读取索引，那么 MySQL 就会极大地减少数据访问量。这对缓存的负载非常重要，因为这种情况下响应时间大部分花费在数据拷贝上。覆盖索引对于 I/O 密集型的应用也有帮助，因为比数据更小，更容易全部放入内存中。

- 因为索引是按照列值顺序存储的（至少在单个页内是如此），所以对于 I/O 密集型的范围查询会比随机从磁盘读取第一行数据的 I/O 要少得多。

- 一些存储引擎如 MyISAM 在内存中只缓存索引，数据则依赖于操作系统来缓存，因此要访问数据需要一次系统调用。这可能会导致严重的性能问题，尤其是那些系统调用占了数据访问中的最大开销的场景。

- 由于 InnoDB 的聚簇索引、覆盖索引对 InnoDB 表特别有用。InnoDB 的二级索引在叶子节点中保存了行的主键值，所以如果二级索引能够覆盖查询，则可以避免对主键索引的二次查询。

不是所有类型的索引都可以成为覆盖索引。覆盖索引必须要存储索引列的值，而哈希索引、空间索引和全文索引等都不存储索引列的值，所以 MySQL 只能使用 B-Tree 索引做覆盖索引。另外，不同的存储引擎实现覆盖索引的方式也不同，而且不是所有的引擎都支持覆盖索引。

当发起一个被索引覆盖的查询（也叫做索引覆盖查询）时，在 Explain 的 Extra 列可以看到"Using index"的信息。

## 使用索引扫描来做排序
MySQL 有两种方式可以生成有序的结果：通过排序操作；或者按索引顺序扫描。如果 Explain 的 type 列的值为"index"，则说明MySQL使用了索引扫描来做排序（不要和 Extra 列的"Using index"搞混淆了）。

扫描索引本身是很快的，因为只需要从一条索引记录移动到紧接着的下一条记录。但如果索引不能覆盖查询所需的全部列，那就不得不每扫描一条索引记录就都回表查询一次对应的行。这基本上都是随机 I/O ，因些按索引顺序读取数据的速度通常要比顺序地全表扫描慢，尤其是在 I/O 密集型的工作负载时。

MySQL 可以使用同一个索引既满足排序，又用于查找行。因此，如果可能，设计索引时应该尽可能地同时满足这两种任务，这样是最好的。

只有当索引的列顺序和 ORDER BY 子句的顺序完全一致，并且所有列的排序方向（倒序或正序）都一样时，MySQL 才能够使用索引来对结果做排序。如果查询需要关联多张表，则只有当 ORDER BY 子句引用的字段全部为第一个表时，才能使用索引做排序。 ORDER BY 子句和查找型查询的限制是一样的：需要满足索引的最左前缀的要求，否则，MySQL 都需要执行排序操作，而无法利用索引排序。

有一种情况下 ORDER BY 子句可以不满足索引的最左前缀的要求，就是前导列为常量的时候。如果 WEHRE 子句或者 JOIN 子句中对这些列指定了常量，就可以弥补索引的不足。

例如，在表 rental 中创建索引 ix(rental_date, inventory_id, customer_id)。

- 可以利用索引排序的查询

1. 虽然 ORDER BY 子句不满足索引的最左前缀的要求，但是索引的第一列提供了一个常数。

```sql
SELECT rental_id, staff_id FROM rental WHERE rental_date = '2005-05-25' ORDER BY inventory_id, customer_id;
```

2. 虽然 ORDER BY 子句不满足索引的最左前缀的要求，但是索引的第一列提供了常量条件，而使用第二列进行排序，将两列组合在一起，就形成了索引的最左前缀。

```sql
SELECT rental_id, staff_id FROM rental WHERE rental_date = '2005-05-25' ORDER BY inventory_id DESC;
```

3. 虽然 rental_date 是范围条件，但是 ORDER BY 使用的两列就是索引的最左前缀

```sql
SELECT rental_id, staff_id FROM rental WHERE rental_date > '2005-05-25' ORDER BY rental_date, inventory_id;
```

- 不能利用索引排序的查询

1. 查询使用了两种不同的排序方式

```sql
SELECT rental_id, staff_id FROM rental WHERE rental_date = '2005-05-25' ORDER BY inventory_id DESC, customer_id ASC;
```

2. 查询的 ORDER BY 子句中引用了一个不在索引中的列

```sql
SELECT rental_id, staff_id FROM rental WHERE rental_date = '2005-05-25' ORDER BY inventory_id, staff_id;
```

3. 查询的 WHERE 和 ORDER BY 中的列无法组合成索引的最左前缀

```sql
SELECT rental_id, staff_id FROM rental WHERE rental_date = '2005-05-25' ORDER BY customer_id;
```

4. 查询在索引列的第一列上是范围条件，所以 MySQL 无法使用索引的其余列

```sql
SELECT rental_id, staff_id FROM rental WHERE rental_date > '2005-05-25' ORDER BY inventory_id, customer_id;
```

5. 查询在 inventory_id 列上有多个等于条件，对于排序来说，这也是一种范围查询

```sql
SELECT rental_id, staff_id FROM rental WHERE rental_date = '2005-05-25' AND inventory_id IN (1, 2) ORDER BY customer_id;
```

## 冗余和重复索引
**MySQL 允许在相同列上创建多个索引，无论是有意的还是无意的。MySQL 需要单独维护重复的索引，并且优化器在优化查询的时候也需要逐个地进行考虑，这会影响性能。**

重复索引是指在相同的列上按照相同的顺序创建的相同类型的索引。应该避免这样创建重复索引，发现以后也应该立即移除。

有时会在不经意间创建了重复索引，例如下面的代码：

```sql
CREATE TABLE test(
  ID INT NOT NULL PRIMARY KEY,
  A INT NOT NULL,
  B INT NOT NULL,
  UNIQUE(ID),
  KEY(ID)
);
```

一个经验不足的用户可能是想创建一个主键，先加上唯一限制，然后再加上索引以供查询使用。事实上，MySQL 的唯一限制和主键限制都是通过索引实现的，因些，上面的写法实际上在相同的列上创建了三个重复的索引。通常并没有理由这样做，除非是在同一列上创建不同类型的索引来满足不同的查询需求。

冗余索引和重复索引有一些不同。如果创建了索引 (A, B)，再创建索引 (A) 就是冗余索引，因为这只是前一个索引的前缀索引。因此索引 (A, B) 也可以当作索引 (A) 来使用（这种冗余只是针对 B-Tree 索引来说的）。但是如果再创建索引 (B, A)，则不是冗余索引，索引 (B) 也不是，因为 B 不是索引  (A, B) 的最左前缀列。另外，其他不同类型的索引（例如哈希索引或者全文索引）也不会是 B-Tree 索引的冗余索引，而无论覆盖的索引列是什么。

冗余索引通常发生在为表添加新索引的时候。例如，有人可能会增加一个新的索引 (A, B)，而不是扩展已有的索引 (A)。还有一种情况是将一个索引扩展成 (A, ID)，其中 ID 是主键，对于 InnoDB 来说主键列已经包含在二级索引中了，所以这也是冗余的。

**大多数情况下都不需要冗余索引，应该尽量扩展已有的索引而不是创建新的索引。但也有时候出于性能方面的考虑需要冗余索引，因为扩展已有的索引会导致其变得太大，从而影响其他使用该索引的查询的性能。**

例如， userinfo 表中有一个索引 ix(state_id)，假设查询名为 Q1：

```sql
SELECT id FROM userinfo WHERE state_id = 5;
```

还有一个查询需要检索几个列的值，假设查询名为 Q2：

```sql
SELECT state_id, city, address FROM userinfo WHERE state_id = 5;
```

对于这个查询，提升该查询性能的最简单办法就是把 ix(state_id) 扩展为 ix(state_id, city, address)，让索引能覆盖查询。索引扩展后，Q2运行得更快了，但是 Q1 却变慢了。如果我们想让两个查询都变得更快，就需要两个索引，尽管这样一来原来的单列索引是冗余的了。

## 索引和锁
索引可以让查询锁定更少的行。如果你的查询从不访问那些不需要的行，那么就会锁定更少的行，从两个方面来看这对性能都有好处。首先，虽然 InnoDB 的行锁效率很高，内存使用也很少，但是锁定行的时候仍然会带来额外开销；其次，锁定超过需要的行会增加锁争用并减少并发性。

InnoDB 只有在访问行的时候才会对其加锁，而索引能够减少 InnoDB 访问的行数，从而减少锁的数量。但这只有当 InnoDB 在存储引擎层能够过滤掉所有不需要的行时才有效。如果索引无法过滤掉无效的行，那么在 InnoDB 检索到数据并返回给服务器层以后，MySQL 服务器才能应用 WHERE 子句。这时经无法避免锁定行了。

通过下面的例子可以很好地了解这些情况：

```sql
SET AUTOCOMMIT = 0;
BEGIN;
SELECT actor_id FROM actor WHERE actor_id < 5 AND actor_id <> 1 FOR UPDATE;
+----------+
| actor_id |
+----------+
|        2 |
|        3 |
|        4 |
+----------+
```

这条查询仅仅会返回 2 ~ 4 之间的行，但是实际上获取了 1 ~ 4 之间的行的排他锁。InnoDB会锁住第 1 行，这是因为 MySQL 为该查询选择的执行计划是索引范围扫描：

```sql
EXPLAIN SELECT actor_id FROM actor WHERE actor_id < 5 AND actor_id <> 1 FOR UPDATE;
+----+-------------+----------+------------+-------+---------------+---------+---------+------+------+----------+--------------------------+
| id | select_type | table    | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra                    |
+----+-------------+----------+------------+-------+---------------+---------+---------+------+------+----------+--------------------------+
|  1 | SIMPLE      | actor    | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL |    4 |      100 | Using where; Using index |
+----+-------------+----------+------------+-------+---------------+---------+---------+------+------+----------+--------------------------+
```

换句话说，**底层存储引擎的操作是"从索引的开头开始获取满足条件 actor_id < 5 的记录"，服务器并没有告诉 InnoDB 可以过滤第 1 行的 WHERE 条件。注意到 EXPLAIN 的 Extra 列出现了 "Using where"，这表示 MySQL 服务器将存储引擎返回行以后再应用 WHERE 过滤条件。**

下面的第二个查询就能证明第 1 行确实已经被锁定，尽管第一个查询的结果中并没有这个第 1 行。保持第一个连接打开，然后开启第二个连接并执行如下查询：

```sql
SET AUTOCOMMIT = 0;
BEGIN;
SELECT actor_id FROM actor WHERE actor_id =1 FOR UPDATE;
```

这个查询将会挂起，直到第一个事务释放第 1 行的锁。这个行为对于基于语句的复制的正常运行来说是必要的。

就像这个例子显示的，即使使用了索引，InnoDB 也可能锁住一些不需要的数据。如果不能使用索引查找和锁定行的话问题可能会理糟糕，MySQL 会做全表扫描并锁住所有的行，而不管是不是需要。

**关于 InnoDB、索引和锁有一些很少有人知道的细节：InnoDB 在二级索引上使用共享（读）锁，但访问主键索引需要排他（写）锁。**

## 支持多种过滤条件
现在需要看看哪些列拥有很多不同的取值，哪些钱在 WHERE 子句中出现得最频繁。在有更多不同值的列上创建索引的选择性会更好。一般来说这样做都是对的，因为可以让 MySQL 更有效地过滤掉不需要的行。

**country 列的选择性通常不高，但可能很多查询都会用到。sex 列的选择性肯定很低，但也会在很多查询中用到。所以考虑到使用的频率，还是建议在创建不同组合索引的时候将 (sex, country) 列作为前缀。**

当设计索引时，不要只为现有的查询考虑需要哪些索引，还需要考虑对查询进行优化。如果发现某些查询需要创建新索引，但是这个索引又会降低另一些查询的效率，那么应该想一下是否能优化原来的查询。应该同时优化查询和索引以找到最佳的平衡，而不是闭门造车去设计最完美的索引。

**接下来，需要考虑其他常见 WHERE 条件的组合，并需要了解哪些组合在没有合适索引的情况下会很慢。(sex, country, age) 上的索引就是一个很明显的选择，另外很有可能还需要 (sex, country, region, age) 和 (sex, country, region, city, age) 这样的组合索引。 **

这样就会需要大量的索引。如果想尽可能重用索引而不是建立大师的组合索引，可以使用前面提到的 IN() 的技巧来避免同时需要 (sex, country, age) 和 (sex, country, region, age) 的索引。如果没有指定这个字段搜索，就需要定义一个全部国家列表，或者国家的全部地区列表，来确保索引前缀有同样的约束（组合所有国家、地区、性别将会是一个非常大的条件）。这些索引将满足大部分最常见的搜索查询。

你可能已经注意到了，我们一直将 age 列放在索引的最后面。age 列有什么特殊的地方吗？为什么要放在索引的最后？我们总是尽可能让 MySQL 使用更多的索引列，**因为查询只能使用索引的最左前缀，直到遇到第一个范围条件列。**前面提到的列在 WHERE 子句中都是等于条件，但是 age 列则多半是范围查询（例如查找年龄在 18 ~ 25 岁之间的人）。

当然，也可以使用 IN() 来代替范围查询，例如年龄条件改写为 IN(18, 19, 20, 21, 22, 23, 24, 25)，但不是所有的范围查询都可以转换。 这里描述的基本原则是，尽可能将需要做范围查询的列放到索引的后面，以便优化器能使用尽可能多的索引项。

前面提到可以在索引中加入更多的列，并通过 IN() 的方式覆盖那些不在 WHERE 子句中的列。但这种技巧也不能滥用，否则可能会带来麻烦。因为每额外增加一个 IN() 条件，优化器需要做的组合都将以指数形式增加，最终可能会极大地降低查询性能。考虑下面的 WHERE 子句：

```sql
WHERE eye_color IN ('brown', 'blue', 'hazel')
  AND hair_color IN ('black', 'red', 'blonde', 'brown')
  AND sex IN ('M', 'F')
```

优化器则会转化成 4 * 3 * 2 = 24 种组合，执行计划需要检查 WHERE 子句中所有的24种组合。对于 MySQL 来说，24 种组合并不夸张，但如果组合数达到上千个则需要特别小心。**老版本的 MySQL 在 IN() 组合条件过多的时候会有很多问题。查询优化可能需要花费很多时间，并消耗大量的内存。新版本的 MySQL 在组合数超过一定数量之后就不再进行执行计划评估了，这可能会导致 MySQL 不能很地利用索引。**

## 避免多个范围条件
假设有如下查询：
```sql
WHERE eye_color IN ('brown', 'blue', 'hazel')
  AND hair_color IN ('black', 'red', 'blonde', 'brown')
  AND sex IN ('M', 'F')
  AND last_online > DATE_SUB(NOW(), INTERVAL 7 DAY)
  AND age BETWEEN 18 AND 25
```

```
从 EXPLAIN 的输出很难区分 MySQL 是要查询范围值，还是查询列表值。EXPLAIN 使用同样的词"range"来描述这两种情况。例如，从 type 列来看，MySQL 会把下面这种查询当作是"range"类型：

EXPLAIN SELECT actor_id FROM actor WHERE actor_id >　45 \G
******************* 1.row *******************
         id: 1
select_type: SIMPLE
      table: actor
       type: range

EXPLAIN SELECT actor_id FROM actor WHERE actor_id IN(1, 4, 99) \G
******************* 1.row *******************
         id: 1
select_type: SIMPLE
      table: actor
       type: range
       
从 EXPLAIN 的结果是无法区分这两者的，但可以从值的范围和多个等于条件来得出不同。在我们看来，第二个查询就是多个等值条件查询。

这两种访问效率是不同的。对于范围条件查询，MySQL 无法再使用范围列后面的其他索引列了，但是对于"多个等值条件查询"则没有这个限制。
```

这个查询有一个问题：它**有两个范围条件，last_online 列和 age 列，MySQL 可以使用 last_online 列索引或者 age 列索引，但无法同时使用它们。**

如果条件中只有 last_online 而没有 age，那么我们可能考虑在索引的后面加上 last_online 列。这里考虑如果我们无法把 age 字段转换为一个 IN() 的列表，并且仍要求对于同时有 last_online 和 age 这两个维度的范围查询的速度很快，那该怎么办？答案是，很遗憾没有一个直接的办法能够解决这个问题。

如果未来版本的 MySQL 能够实现松散索引扫描，就能在一个索引上使用多个范围条件，那也就不需要为上面考虑的这类查询使用 IN() 列表了。

## 优化排序
使用文件排序对小数据集是很快的，但如果一个查询匹配的结果有上百万行的话会怎样？例如如果 WHERE 子句只有 sex 列，如何排序？

对于那些选择性非常低的列，可以增加一些特殊的索引来做排序。例如，可以合建 (sex, rating) 索引用于下面的查询：

```sql
SELECT * FROM profiles WHERE sex = 'M' ORDER BY rating LIMIT 10;
```

这个查询同时使用了 ORDER BY 和 LIMIT，如果没有索引的话会很慢。

即使有索引，如果用户界面上需要翻页，并且翻页翻到比较靠后时查询也可能非常慢。下面这个查询就通过 ORDER BY 和 LIMIT 偏移量的组合翻页到很后面：

```sql
SELECT * FROM profiles WHERE sex = 'M' ORDER BY rating LIMIT 100000， 10;
```

**无论如何创建索引，这种查询都是个严重的问题。因为随着偏移量的增加，MySQL 需要花费大量的时间来扫描需要丢弃的数据。反范式化、预先计算和缓存可能是解决这类查询的仅有策略。一个更好的办法是限制用户能够翻页的数量，实际上这对用户体验的影响不大，因为用户很少会真正在乎搜索结果的第 10000 页。**

优化这类索引的另一个比较好的策略是使用延迟关联，通过使用覆盖索引查询返回需要的主键，再根据这些主键关联原表获得需要的行。这样可以减少 MySQL 扫描那些需要丢弃的行数。下面这个查询显示了如何高效地使用 (sex, rating) 索引进行排序和分页：

```sql
SELECT p.name FROM profiles AS p INNER JOIN (
  SELECT id FROM profiles 
  WHERE sex = 'M' ORDER BY rating LIMIT 100000， 10
) AS x ON p.id = x.id;
```

# 索引的使用策略
## 需要使用索引的情形

- 主键自动建立唯一索引

- 经常作为查询条件在WHERE或者ORDER BY 语句中出现的列要建立索引

- 作为排序的列要建立索引

- 查询中与其他表关联的字段，外键关系建立索引

- 高并发条件下倾向组合索引

- 用于聚合函数的列可以建立索引，例如使用了max(col1)或者count(col1)时的col1就需要建立索引

## 不需要使用索引的情形

- 经常增删改的列不要建立索引

- 有大量重复的列不要建立索引

- 表记录太少不要建立索引，只有当数据表里有了足够多的数据时，建立索引才有实际意义。

## 索引失效的情况

- 组合索引必须遵循最左前缀原则，否则，组合索引失效

- 在组合索引中不能有列的值为NULL，否则，组合索引失效

- 在一个查询语句中，索引只能使用一次，如果在WHERE中使用了，那么在ORDER BY中就不要用了

- LIKE '%word%' 查询不会使用索引，也就是索引会失效，但是 LIKE 'word%' 查询会使用索引

- 在索引的列上使用表达式或者函数会使索引失效而进行全表扫描

```sql
错误的用法：SELECT * FROM test WHERE id - 1 = 9; 

正确的用法：SELECT * FROM test WHERE id = 10; 
```

```sql
错误的用法：SELECT * FROM test WHERE SUBSTR(name, 1, 2) = 'x/'; -- name = 'x/y/z'

正确的用法：SELECT * FROM test WHERE name LIKE 'x/%'; 
```

- 在查询条件中使用 != 、 < 、 > 会导致索引失效。但是，如果对主键索引使用 != 、 < 、 > ，则索引不会失效

- 在查询条件中使用 IS NULL 或者 IS NOT NULL 会导致索引失效

- 在查询条件中使用 NOT IN 或者 NOT EXIST 会导致索引失效

- 隐式转换会导致索引失效，比如字段 age 是 int 类型

```sql
错误的用法：SELECT * FROM test WHERE age = '20'; 

正确的用法：SELECT * FROM test WHERE age = 20; 
```

- 在查询条件中使用 OR 会导致索引失效，除非 OR 连接的每个条件都加上索引，这时应该改为两次查询，然后用 UNION ALL 连接起来

- 如果排序的字段使用了索引，那么 SELECT 的字段也要是索引字段，否则索引失效。如果排序的是主键索引，则SELECT * 不会导致索引失效

- 尽量不要使用多列排序，如果一定要，就使用组合索引

- 如果mysql估计使用全表扫描要比使用索引快，则不使用索引

- 尽量不使用 IN 查询，而使用 JOIN ，必要时可借助临时表作 JOIN 查询

# EXPLAIN用法之Extra

[EXPLAIN Mysql官网](https://dev.mysql.com/doc/refman/5.7/en/explain-output.html "EXPLAIN Mysql官网")

# Explain extend调优

```sql
mysql> EXPLAIN EXTENDED SELECT `name` FROM test WHERE id IN (SELECT id FROM test WHERE id >= 10);
+----+-------------+-----------+------------+--------+---------------+---------+---------+------------------------+---------+----------+--------------------------+
| id | select_type | table     | partitions | type   | possible_keys | key     | key_len | ref                    | rows    | filtered | Extra                    |
+----+-------------+-----------+------------+--------+---------------+---------+---------+------------------------+---------+----------+--------------------------+
|  1 | SIMPLE      | test | NULL       | range  | PRIMARY,id    | id      | 4       | NULL                   | 1384484 |      100 | Using where; Using index |
|  1 | SIMPLE      | test | NULL       | eq_ref | PRIMARY,id    | PRIMARY | 4       | db.test.id |       1 |      100 | NULL                     |
+----+-------------+-----------+------------+--------+---------------+---------+---------+------------------------+---------+----------+--------------------------+
2 rows in set

mysql> SHOW WARNINGS;
+---------+------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Level   | Code | Message                                                                                                                                                                                                                                 |
+---------+------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Warning | 1681 | 'EXTENDED' is deprecated and will be removed in a future release.                                                                                                                                                                       |
| Note    | 1003 | /* select#1 */ select `db`.`test`.`name` AS `name` from `db`.`test` join `db`.`test` where ((`db`.`test`.`id` = `db`.`test`.`id`) and (`db`.`test`.`id` >= 10)) |
+---------+------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
2 rows in set
```

在 Result2 的 Message 列中，可以看到 mysql 对 sql 优化的建议语句
